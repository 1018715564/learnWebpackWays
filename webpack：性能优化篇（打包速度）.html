<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600986 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1687"/>

<div>
<span><div><div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">从技术手段上提高打包速度</span></font></div><div><font style="font-size: 16pt;"><br/></font></div><ol><li><div>跟上技术的迭代（升级node，npm或者yarn），因为webpack是基于node的，node的升级对webpack性能也会有提升，npm中很多的依赖包存在升级，那么对打包的速度也是有提高的</div></li><li><div>在尽可能少的模块上应用loader，loader的使用会对更多的文件去解析，所以在配置文件中，比如要把node_modules中的文件进行排除，因为可能依赖项已经被打包过，再打包一遍会更浪费事件</div></li><li><div>关于plugins的使用，尽量使用社区/官方推荐或者非常流行的插件，因为通常这类插件的稳定性和易用性得到了大多数人的认可，而第三方公司或者私人的插件可能会造成对项目优化不友好的地方</div></li></ol><div>所以尽量避免使用plugins</div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">通过resolve配置来提升打包速度</span></font></div><div><br/></div><div>webpack中的resolve可以帮助我们引入第三方模块或者组件的时候，可以能够更方便的引入，比如通常在写vue的时候</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import commonHeader from &quot;../components/commonHeader&quot;</div></div><div><br/></div><div>不用指定其组件的后缀“vue”就可以找到，那么vue-cli是如何做到的呢，webpack配置就是如下：</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>resolve: {</div><div>    extensions: [&quot;vue&quot;, &quot;js&quot;, &quot;jsx&quot;]</div><div>}</div></div><div><br/></div><div>可以通过这样简单配置，如果在目录下，没有找到对应的文件，那么就会再次遍历去寻找配置项指定后缀文件，但是这样的配置如果我们配置的过多的话，比如像这样</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">[&quot;jpg&quot;, &quot;png&quot;, &quot;json&quot;]</span></div></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">一股脑地全部配上，这样就会在webpack打包中增加压力，延缓打包速度（因为要多次遍历查询）</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">所以一般的解决方案是：“只配置逻辑文件，如jsx，js，vue”等</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">如果我们引入配置的时候，引入的路径是这样的</span></div><div><span style="font-size: 9pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import common from &quot;./common/&quot;</div></div><div><br/></div><div>会发现，当组件的名称如果叫index.**时，这句代码是正确的，如果是其他名称，就‘</div><div><br/></div><div>会报错，是因为webpack的默认项会把index当作主文件，那么我们也可以通过这样的配置进行更改：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>mainFiles: [&quot;index&quot;, &quot;common&quot;]</div></div><div><br/></div><div>resolve中也还有其他常用的配置</div><div><br/></div><div>比如alias（别名）,比如我要这样引入</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import common from &quot;shenhao&quot;</div></div><div><br/></div><div>我们可以设置一个别名</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>alias: {</div><div>    shenhao: path.resolve(__dirname, ../src/common)</div><div>}</div></div><div><br/></div><div>然后我们就可以使用alias进行引入，感觉通过这样的描述会感觉这个属性非常鸡肋，其实并不然，比如非常复杂的目录结构，要引入一个包要写很长的路径</div><div><br/></div><div>如果写过vue的开发者来讲，@符号就表示src下的根目录，那么这个@就是一个别名</div><div><br/></div><div>但是为了webpack的打包性能，尽量不要使用过多的配置alias和上面的extensions，配置项目中最常用的即可哟</div><div><br/></div><div><br/></div><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">使用DllPlugin提高打包速度</span></span></div><div><span style="font-size: 16pt;"><br/></span></div><div>我们尝试使用一个babel打包一个react的程序，如图：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import React, { Component } from 'react';</div><div>import ReactDom from 'react-dom';</div><div>import _ from 'lodash';</div><div><br/></div><div><br/></div><div>class App extends Component {</div><div>    render() {</div><div>        return (</div><div>            &lt;div&gt;</div><div>                &lt;div&gt;{_.join([1,2,3,4,5], &quot;...&quot;)}&lt;/div&gt;</div><div>            &lt;/div&gt;</div><div>        )</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div>let haha = document.createElement(&quot;div&quot;);</div><div>document.body.appendChild(haha);</div><div>ReactDom.render(&lt;App /&gt;, haha);</div></div><div><span style="font-size: 16pt;"><br/></span></div><div>经过多次打包，速度平均稳定在</div><div><br/></div><div><img src="webpack：性能优化篇（打包速度）_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>那么问题来了，我们每一次打包都会分析react,react-dom等库，我们可以尝试把这些库只分析一次，之后的打包读这些分析过的文件即可</div><div><br/></div><ol><li><div><span style="font-weight: bold;">首先我们需要额外的分析这些第三方库</span></div></li></ol><div><br/></div><div>新建webpack.dll.js</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>const path = require(&quot;path&quot;);</div><div><br/></div><div><br/></div><div>module.exports = {</div><div>    mode: &quot;production&quot;,</div><div>    entry: {</div><div>        vendors: [&quot;react&quot;, &quot;react-dom&quot;, &quot;lodash&quot;]</div><div>    },</div><div>    output: {</div><div>        path: path.resolve(__dirname, 'dll'),</div><div>        filename: '[name].dll.js',</div><div>        <font color="#EB0073">library: &quot;[name]&quot;</font></div><div>    }</div><div>}</div></div><div><br/></div><div>我们向外暴漏一下全局变量，然后我们则要让打包后的index.html去引入这个第三方库编译后的js</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">ps: 要让打包后的index.html自动引入，则需要</span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">add-asset-html-webpack-plugin这个插件，做一个简单配置即可（必须）</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div>但是我们在main.js中的引入</div><div><br/></div><div><img src="webpack：性能优化篇（打包速度）_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>根本引入的不是我们编译好的js文件，还是引入的是node_modules中的</div><div><br/></div><div>        2. <span style="font-weight: bold;">让main.js引入的文件映射到编译过的第三方库文件中</span></div><div><br/></div><div>首先配置一下，webpack.dll.js中我们增加一句代码</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    plugins: [new webpack.DllPlugin({</div><div>        name: &quot;[name]&quot;,</div><div>        path: path.resolve(__dirname, &quot;dll/[name].manifest.json&quot;)</div><div>    })]</div></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">引入了webpack之后，使用了webpack中的DllPlugin模块，生成的分析文件的name就是暴漏的全局变量，path就是分析文件的地址</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">我们将使用全局变量+分析文件来做映射，让代码中的import这样的语句，映射到我们分析的js文件中，而不是引入node_modules中</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">所以在webpack.config.js中加入</span></div><div><span style="font-size: 9pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>new webpack.DllReferencePlugin({</div><div>   manifest: path.resolve(__dirname, &quot;dll/vendors.manifest.json&quot;)</div><div>})</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">这边我们传递参数的内容就是生成出来的映射文件，这个时候我们重新打包会发现，打包速度会少200-300毫秒（根据电脑性能不同）</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">流程梳理：</span></div><div><span style="font-size: 9pt;"><br/></span></div><ol><li><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">将不会变更的库进行单独打包，并且暴漏一个</span><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">全局变量</span><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">（核心）</span></div></li><li><div>打包之后使用DllPlugin进行分析，<span style="font-weight: bold;">生成一个映射文件，条件是必须有一个全局变量</span></div></li><li><div>在打包main.js中，webpack会对引入的模块进行查询，<span style="font-weight: bold;">而common.js使用了DllReferencePlugin这个插件</span>，会在对应的映射文件中查询如果对应的单独库js文件存在引入的模块，那么main.js将直接把单独库js文件中的对应的内容为自己所用，就不会在去node_modules中去寻找模块，通过这一系列，将减少打包时间</div></li></ol><div><br/></div><div><br/></div><div>那么在大型项目中，需要拆分很多很多的dll.js和manifest.json，那么如何做到“智能的”让webpack使用DllReferencePlugin和add-asset-html-webpack-plugin呢，在看这个问题之前，我们来尝试一下传统方法</div><div><br/></div><div><span style="font-weight: bold;">不智能的做法：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>entry: {</div><div>        vendors: [&quot;lodash&quot;],</div><div>        react: [&quot;react&quot;, &quot;react-dom&quot;]</div><div>    },</div></div><div><br/></div><div>我们假设要生成2个分析文件</div><div><br/></div><div>那么我们在webpack.config.js需要这样做</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>plugins: [new HtmlWebpackPlugin({</div><div>        filename: 'index.html'</div><div>    }), <font color="#BC0058">new AddAssetsHtmlPlugin({</font></div><div><font color="#BC0058">        filepath: path.resolve(__dirname, &quot;dll/vendors.dll.js&quot;)</font></div><div><font color="#BC0058">    }),new AddAssetsHtmlPlugin({</font></div><div><font color="#BC0058">        filepath: path.resolve(__dirname, &quot;dll/react.dll.js&quot;)</font></div><div><font color="#BC0058">    }), new webpack.DllReferencePlugin({</font></div><div><font color="#BC0058">        manifest: path.resolve(__dirname, &quot;dll/vendors.manifest.json&quot;)</font></div><div><font color="#BC0058">    }),new webpack.DllReferencePlugin({</font></div><div><font color="#BC0058">        manifest: path.resolve(__dirname, &quot;dll/react.manifest.json&quot;)</font></div><div><font color="#BC0058">    })</font>]</div></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">居然要配置2遍插件</span></div><div><span style="font-size: 9pt;"><br/></span></div><ol><li><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">每个被分析的js都要暴漏一个全局变量，这个之前也说过，需要把每一个文件添加到html中，有了全局变量之后，才能让webpack去用json去查询模块</span></div></li></ol><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">那么我们假象一下，一个项目如果需要规定上10个，上100个的入口模块，那么就要配置200次（100次添加js到html，100次查询json依赖文件）</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">这显然是不可取的，所以我们可以用相对智能的方式去做哟，需要用到node一点东西哟；</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">智能的做法：</span></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">思路1： 在运行之前，肯定是解析过了dll.js的，所以运行webpack.config.js之前，项目中应该会有100个**.dll.js , 100个**.manifest.json</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">我们抽象一下webpack.config.js中的plugins，定义一个数组</span></div><div><span style="font-size: 9pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>const fs = require(&quot;fs&quot;);</div><div>const plugins = []; // 抽象plugins数组</div><div>// 读取dll目录下的数据</div><div>let readFileList = fs.readdirSync(path.resolve(__dirname, &quot;dll&quot;));</div><div>console.log(readFileList);</div><div>||</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"> | |</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>[ 'react.dll.js',</div><div>  'react.manifest.json',</div><div>  'vendors.dll.js',</div><div>  'vendors.manifest.json' ]</div></div><div><br/></div><div>循环这个数组</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>const files = fs.readdirSync(path.resolve(__dirname, '../dll'));</div><div>files.forEach(file =&gt; {</div><div>    if(/.*\.dll.js/.test(file)) {</div><div>        plugins.push(new AddAssetHtmlWebpackPlugin({</div><div>            filepath: path.resolve(__dirname, '../dll', file)</div><div>        }) )</div><div>    }</div><div>    if(/.*\.manifest.json/.test(file)) {</div><div>        new webpack.DllReferencePlugin({</div><div>            manifest: path.resolve(__dirname, &quot;dll&quot;, file)</div><div>        }) )</div><div>    }</div><div>})</div></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">判断循环的当前file名称是不是dll.js，如果是dll.js，就在数组中添加对应的</span><span style="font-size: 9pt; font-family: Monaco;"><span style="font-family: Monaco; font-size: 9pt; color: rgb(188, 0, 88);">AddAssetHtmlWebpackPlugin</span> <span style="font-family: Monaco; font-size: 9pt;">插件，反之就</span></span><span style="font-size: 9pt;"><span style="font-family: Monaco; font-size: 9pt; color: rgb(188, 0, 88);">DllReferencePlugin 添加</span><span style="font-family: Monaco; font-size: 9pt;">这个插件</span></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; font-family: Monaco;">大功告成，所以每当有一个新的入口时候，只需要</span></div><div><span style="font-size: 9pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>entry: {</div><div>        vendors: [&quot;lodash&quot;],</div><div>        react: [&quot;react&quot;, &quot;react-dom&quot;]</div><div>    },</div></div><div><br/></div><div>在webpack.dll.js随意配置即可， 但是每次打包之前，必须要先生成dll.js和manifest.json文件</div></div><div><br/></div><div><font style="font-size: 16pt;"><b>控制包文件大小</b><br/></font></div><div><font style="font-size: 16pt;"><b><br/></b></font></div><div>在日常写代码的时候，一些引入的模块，没有用到，那么可以借助treeshaking和codesplit一些代码分割的插件，来控制包大小</div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><b>多线程打包</b><br/></font></div><div><font style="font-size: 16pt;"><b><br/></b></font></div><div>webpack基于node的，是单线程进行打包，我们可以在单页应用使用<b>thread-loader</b>来对单页应用进行多线程进行打包，多页应用则使用<b>parallel-webpack</b>进行打包，还有一个是<b>happypack</b></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><b>合理使用soucemap<br/></b></font></div><div><font style="font-size: 16pt;"><b><br/></b></font></div><div>合理选用适合项目的soucemap模式，过细的soucemap会增大打包压力，所以根据调整soucemap也可以调优</div><div><br/></div><div><font style="font-size: 16pt;"><b>结合stats<br/></b></font></div><div><br/></div><div><font style="font-size: 10pt;">一些第三方的网站可以分析webpack的打包文件，分析出打包的文件，哪个文件大，哪个文件慢，从而达到目的性的调优<br/></font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 16pt;"><b>开发环境内存编译</b></span></div><div><span style="font-size: 16pt;"><b><br/></b></span></div><div><font style="font-size: 10pt;">在开发环境时，使用的webpack-dev-server就是通过内存存储打包后的文件，所以内存的读写一定比硬盘读写快，所以使用内存编译的方式，打包速度也会加快<br/></font></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 16pt;"><b>开发环境无用插件剔除</b></span></div><div><span style="font-size: 16pt;"><b><br/></b></span></div><div><font style="font-size: 10pt;">开发环境下，不需要过多的插件进行压缩等等，所以剔除无用插件也可以达到调优目的；</font></div></span>
</div></body></html> 